<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Coloring Algo Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #0f172a;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            height: 100vh;
            margin: 0;
            box-sizing: border-box;
        }
        h1 { 
            color: #1e293b; 
            margin-bottom: 20px; 
            font-weight: 800;
            letter-spacing: -0.5px;
            font-size: 28px;
        }
        
        .main-layout {
            display: flex;
            gap: 24px;
            align-items: flex-start;
            max-width: 1200px;
            width: 100%;
        }

        /* Controls Section */
        .controls {
            background: white;
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 4px 20px -5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 240px;
            flex-shrink: 0;
        }
        
        .control-group-title {
            font-size: 11px;
            text-transform: uppercase;
            color: #94a3b8;
            font-weight: 700;
            letter-spacing: 0.5px;
            margin-top: 8px;
            margin-bottom: 4px;
        }

        button {
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            overflow: hidden;
        }
        button:hover { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        button:active { transform: translateY(0); }

        .btn-gen { background-color: #f1f5f9; color: #334155; }
        .btn-gen:hover { background-color: #e2e8f0; }
        
        .btn-tiny { background-color: #e0f2fe; color: #0369a1; border: 1px solid #bae6fd; }

        .btn-algo { color: white; margin-bottom: 2px; }
        .btn-greedy { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .btn-wp { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .btn-dsatur { background: linear-gradient(135deg, #10b981, #059669); }
        .btn-sa { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        .btn-dp { background: linear-gradient(135deg, #06b6d4, #0891b2); } 

        /* Canvas Section */
        #canvas-wrapper {
            position: relative;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            overflow: hidden;
            background: white;
            flex-grow: 1;
        }
        
        canvas {
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f8fafc 100%);
            width: 100%;
            cursor: crosshair; /* Hint that interaction is possible */
        }

        /* Logs Section */
        .log-panel {
            width: 300px;
            height: 580px;
            background: #1e293b; 
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }
        .log-header {
            background: #0f172a;
            padding: 16px;
            font-weight: 600;
            color: #f8fafc;
            border-bottom: 1px solid #334155;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .log-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #cbd5e1;
        }
        .log-content::-webkit-scrollbar { width: 6px; }
        .log-content::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

        .log-entry { margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #334155; line-height: 1.5; }
        .log-entry span { opacity: 0.5; margin-right: 8px; font-size: 10px; }
        
        .log-highlight { color: #60a5fa; font-weight: bold; } 
        .log-success { color: #4ade80; font-weight: bold; } 
        .log-warn { color: #fbbf24; } 
        .log-error { color: #f87171; } 
        .log-info { color: #94a3b8; font-style: italic; }

        .stats-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 16px 24px;
            background: white;
            border-top: 1px solid #e2e8f0;
            box-sizing: border-box;
        }
        .status-text { font-weight: 700; color: #334155; font-size: 15px; }
        
        .legend { display: flex; gap: 16px; font-size: 13px; color: #64748b; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }

        .badge {
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: none;
        }
        .badge.valid { background: #dcfce7; color: #15803d; border: 1px solid #bbf7d0; }
        .badge.invalid { background: #fee2e2; color: #b91c1c; border: 1px solid #fecaca; }

        .info-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #475569;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #e2e8f0;
        }
    </style>
</head>
<body>

    <h1>Graph Coloring Algorithm Visualizer</h1>
    
    <div class="main-layout">
        
        <!-- Sidebar Controls -->
        <div class="controls">
            <div class="control-group-title">Graph Generator</div>
            <button class="btn-gen" onclick="resetGraph(12)"> <!-- Reduced N slightly for clarity -->
                <span>Normal Graph</span>
                <span>(N=12)</span>
            </button>
            <button class="btn-tiny" onclick="resetGraph(6)">
                <span>Tiny Graph (For DP)</span>
                <span>(N=6)</span>
            </button>
            
            <div style="height: 10px;"></div>
            
            <div class="control-group-title">Constructive Algos</div>
            <button class="btn-algo btn-greedy" onclick="runGreedy()">
                <span>Basic Greedy</span>
                <span>0→N</span>
            </button>
            <button class="btn-algo btn-wp" onclick="runWelshPowell()">
                <span>Welsh-Powell</span>
                <span>Degree</span>
            </button>
            <button class="btn-algo btn-dsatur" onclick="runDSatur()">
                <span>DSatur</span>
                <span>Dynamic</span>
            </button>

            <div style="height: 10px;"></div>

            <div class="control-group-title">Advanced Algos</div>
            <button class="btn-algo btn-sa" onclick="runSimulatedAnnealing()">
                <span>Simulated Annealing</span>
                <span>Meta</span>
            </button>
            <button class="btn-algo btn-dp" onclick="runDP()">
                <span>Dynamic Prog.</span>
                <span>Exact</span>
            </button>
        </div>

        <!-- Main Visualization Area -->
        <div id="canvas-wrapper">
            <div id="infoOverlay" class="info-overlay">Temp: 0 | Conflicts: 0</div>
            <canvas id="graphCanvas" width="700" height="540"></canvas>
            
            <div class="stats-bar">
                <div>
                    <div id="statusText" class="status-text">Ready. Hover nodes to see connections.</div>
                </div>
                <div id="validationBadge" class="badge"></div>
                
                <div class="legend">
                    <div class="legend-item"><div class="dot" style="background: #e2e8f0; border: 2px solid #94a3b8;"></div> Empty</div>
                    <div class="legend-item"><div class="dot" style="background: #22c55e;"></div> Done</div>
                    <div class="legend-item"><div class="dot" style="background: #ef4444; box-shadow: 0 0 8px #ef4444;"></div> Active</div>
                </div>
            </div>
        </div>

        <!-- Live Log Panel -->
        <div class="log-panel">
            <div class="log-header">
                <span>Algo Operations</span>
                <span style="font-size: 10px; color: #94a3b8; background: #1e293b; padding: 2px 6px; border-radius: 4px;">LIVE</span>
            </div>
            <div id="logContent" class="log-content">
                <div class="log-info">Waiting for input...</div>
            </div>
        </div>

    </div>

<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');
    const logContainer = document.getElementById('logContent');
    const validationBadge = document.getElementById('validationBadge');
    const infoOverlay = document.getElementById('infoOverlay');

    // Config
    let NODE_COUNT = 15;
    const RADIUS = 20; // Slightly larger nodes
    let DELAY_MS = 400;

    // State
    let nodes = [];
    let edges = [];
    let isRunning = false;
    let abortController = null;
    
    // Interaction State
    let hoveredNode = null;

    // Professional Palette
    const PALETTE = [
        "#3b82f6", "#ef4444", "#10b981", "#f59e0b", 
        "#8b5cf6", "#ec4899", "#06b6d4", "#84cc16", 
        "#6366f1", "#d946ef"
    ];

    class Node {
        constructor(id, x, y) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.vx = 0; this.vy = 0;
            this.color = null; 
            this.neighbors = [];
            this.degree = 0;
            this.highlight = false; 
        }
    }

    function init() {
        resetGraph(12);
        
        // Add Mouse Listeners for Hover Effect
        canvas.addEventListener('mousemove', (e) => {
            if (isRunning) return; // Disable hover while running to reduce flicker
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            let found = null;
            for(let node of nodes) {
                const dist = Math.hypot(node.x - mouseX, node.y - mouseY);
                if(dist < RADIUS + 5) {
                    found = node;
                    break;
                }
            }
            
            if(hoveredNode !== found) {
                hoveredNode = found;
                draw();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if(hoveredNode) {
                hoveredNode = null;
                draw();
            }
        });
    }

    function addLog(text, type = 'normal') {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        if (type === 'highlight') entry.classList.add('log-highlight');
        if (type === 'success') entry.classList.add('log-success');
        if (type === 'error') entry.classList.add('log-error');
        if (type === 'warn') entry.classList.add('log-warn');
        if (type === 'info') entry.classList.add('log-info');
        
        const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: "numeric", minute: "numeric", second: "numeric" });
        entry.innerHTML = `<span>${time}</span> ${text}`;
        logContainer.prepend(entry);
    }

    function clearLogs() {
        logContainer.innerHTML = '';
    }

    // --- GRAPH GENERATION ---

    function resetGraph(size) {
        if (isRunning && abortController) {
            abortController.abort();
            isRunning = false;
        }

        NODE_COUNT = size;
        nodes = [];
        edges = [];
        hoveredNode = null;
        clearLogs();
        infoOverlay.style.opacity = '0';
        validationBadge.style.display = 'none';
        
        addLog(`Generating ${size < 8 ? 'TINY' : 'NORMAL'} graph (N=${size})...`, "info");

        // 1. Create Nodes
        for (let i = 0; i < NODE_COUNT; i++) {
            nodes.push(new Node(i, Math.random() * canvas.width, Math.random() * canvas.height));
        }

        // 2. Create Edges
        // Backbone
        for(let i=0; i<NODE_COUNT-1; i++) {
             addEdge(i, i+1);
        }
        // Random edges
        const density = size < 10 ? 0.35 : 0.2; // Lower density for clarity
        for (let i = 0; i < NODE_COUNT; i++) {
            for (let j = i + 2; j < NODE_COUNT; j++) {
                if (Math.random() < density) {
                    addEdge(i, j);
                }
            }
        }

        // 3. Physics Layout (Stronger repulsion for clarity)
        runForceLayout(250); 

        clearColors();
        draw();
        statusText.innerText = "Graph Ready. Hover over nodes to check connections.";
        addLog(`Graph created: ${NODE_COUNT} nodes, ${edges.length} edges.`);
    }

    function addEdge(u, v) {
        if (nodes[u].neighbors.includes(nodes[v])) return;
        edges.push([u, v]);
        nodes[u].neighbors.push(nodes[v]);
        nodes[v].neighbors.push(nodes[u]);
        nodes[u].degree++;
        nodes[v].degree++;
    }

    function runForceLayout(iterations) {
        const width = canvas.width;
        const height = canvas.height;
        // Increase ideal distance (k) to spread nodes out more
        const k = Math.sqrt((width * height) / (nodes.length * 0.6)); 
        
        for (let i = 0; i < iterations; i++) {
            // Repulsion (Stronger)
            nodes.forEach(v => {
                v.vx = 0; v.vy = 0;
                nodes.forEach(u => {
                    if (v !== u) {
                        const dx = v.x - u.x;
                        const dy = v.y - u.y;
                        let dist = Math.hypot(dx, dy);
                        if (dist === 0) dist = 0.1;
                        // Stronger repulsion formula
                        const force = (k * k) / dist * 1.5; 
                        v.vx += (dx / dist) * force;
                        v.vy += (dy / dist) * force;
                    }
                });
            });

            // Attraction
            edges.forEach(e => {
                const v = nodes[e[0]];
                const u = nodes[e[1]];
                const dx = v.x - u.x;
                const dy = v.y - u.y;
                let dist = Math.hypot(dx, dy);
                if (dist === 0) dist = 0.1;
                const force = (dist * dist) / k;
                v.vx -= (dx / dist) * force;
                v.vy -= (dy / dist) * force;
                u.vx += (dx / dist) * force;
                u.vy += (dy / dist) * force;
            });

            // Update
            nodes.forEach(v => {
                const dx = (width / 2) - v.x;
                const dy = (height / 2) - v.y;
                v.vx += dx * 0.03; v.vy += dy * 0.03; // Gentle Gravity

                const len = Math.hypot(v.vx, v.vy);
                const step = Math.min(len, 12);
                if (len > 0) {
                    v.x += (v.vx / len) * step;
                    v.y += (v.vy / len) * step;
                }
                
                v.x = Math.max(RADIUS, Math.min(width - RADIUS, v.x));
                v.y = Math.max(RADIUS, Math.min(height - RADIUS, v.y));
            });
        }
    }

    function clearColors() {
        nodes.forEach(n => {
            n.color = null;
            n.highlight = false;
        });
        validationBadge.style.display = 'none';
        draw();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- DRAW EDGES ---
        edges.forEach(edge => {
            const n1 = nodes[edge[0]];
            const n2 = nodes[edge[1]];
            
            // Check if edge should be highlighted
            const isHighlit = n1.highlight || n2.highlight;
            const isHovered = (hoveredNode && (n1 === hoveredNode || n2 === hoveredNode));
            const isActive = isHighlit || isHovered;

            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            
            if (isActive) {
                // Active/Hovered Edge: Pitch Black & Thick
                ctx.strokeStyle = "#1e293b"; 
                ctx.lineWidth = 3.5;
                ctx.globalAlpha = 1.0;
            } else {
                // Normal Edge: Dark Slate (Much clearer than before)
                ctx.strokeStyle = "#94a3b8"; 
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8; // Slight fade for non-active
            }
            
            ctx.stroke();
            ctx.globalAlpha = 1.0; // Reset
        });

        // --- DRAW NODES ---
        nodes.forEach(n => {
            const isHovered = (hoveredNode === n);
            const isNeighbor = (hoveredNode && hoveredNode.neighbors.includes(n));
            const isAlgoActive = n.highlight;

            ctx.beginPath();
            ctx.arc(n.x, n.y, RADIUS, 0, Math.PI * 2);
            
            // Fill
            if (n.color !== null) {
                ctx.fillStyle = PALETTE[n.color % PALETTE.length];
            } else {
                // If hovered or neighbor of hovered, make it slightly darker white
                if (isHovered || isNeighbor) ctx.fillStyle = "#e2e8f0";
                else ctx.fillStyle = "#f8fafc";
            }
            ctx.fill();

            // Border Styling
            if (isAlgoActive) {
                ctx.strokeStyle = "#ef4444"; // Processing Red
                ctx.lineWidth = 4;
            } else if (isHovered) {
                ctx.strokeStyle = "#3b82f6"; // Hover Blue
                ctx.lineWidth = 4;
            } else if (isNeighbor) {
                ctx.strokeStyle = "#3b82f6"; // Neighbor Blue
                ctx.lineWidth = 2.5;
            } else {
                ctx.strokeStyle = "#475569"; // Standard Dark Slate
                ctx.lineWidth = 2;
            }
            
            ctx.stroke();

            // Text ID
            ctx.fillStyle = n.color !== null ? "white" : "#334155";
            ctx.font = "bold 14px Inter";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(n.id, n.x, n.y);
            
            // Debug Info (Degree) - Only show if hovered or highlighting
            if (isHovered || isAlgoActive) {
                 ctx.fillStyle = "#1e293b";
                 ctx.font = "bold 12px Inter";
                 ctx.fillText(`d:${n.degree}`, n.x, n.y - RADIUS - 8);
            }
        });
    }

    async function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function getFirstAvailableColor(node) {
        const used = new Set();
        node.neighbors.forEach(n => {
            if (n.color !== null) used.add(n.color);
        });
        let c = 0;
        while (used.has(c)) c++;
        return c;
    }

    // --- ALGORITHM RUNNERS ---

    function prepareRun(name) {
        if (isRunning) return false;
        isRunning = true;
        hoveredNode = null; // Clear hover state
        abortController = new AbortController();
        clearColors();
        clearLogs();
        addLog(`Starting ${name}...`, "highlight");
        statusText.innerText = `Running ${name}...`;
        return true;
    }

    // 1. GREEDY
    async function runGreedy() {
        if (!prepareRun("Basic Greedy")) return;
        DELAY_MS = 500;

        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            node.highlight = true;
            statusText.innerText = `Visiting Node ${node.id} (Check edges for conflicts)`;
            draw();
            await sleep(DELAY_MS);

            node.color = getFirstAvailableColor(node);
            addLog(`Node ${node.id}: Assigned Color ${node.color}`);
            
            node.highlight = false;
            draw();
        }
        finishRun("Basic Greedy");
    }

    // 2. WELSH-POWELL
    async function runWelshPowell() {
        if (!prepareRun("Welsh-Powell")) return;
        DELAY_MS = 400;
        addLog("Sorting nodes by degree (High -> Low)...", "info");
        
        let sorted = [...nodes].sort((a, b) => b.degree - a.degree);

        for (let node of sorted) {
            node.highlight = true;
            statusText.innerText = `Visiting Node ${node.id} (Degree: ${node.degree})`;
            draw();
            await sleep(DELAY_MS);

            node.color = getFirstAvailableColor(node);
            addLog(`Node ${node.id}: Assigned Color ${node.color}`);
            node.highlight = false;
            draw();
        }
        finishRun("Welsh-Powell");
    }

    // 3. DSATUR
    async function runDSatur() {
        if (!prepareRun("DSatur")) return;
        DELAY_MS = 500;

        let uncolored = nodes.length;
        while (uncolored > 0) {
            let maxSat = -1, maxDeg = -1, bestNode = null;

            for (let node of nodes) {
                if (node.color !== null) continue;
                
                let neighborColors = new Set(node.neighbors.map(n => n.color).filter(c => c !== null));
                let sat = neighborColors.size;

                if (sat > maxSat || (sat === maxSat && node.degree > maxDeg)) {
                    maxSat = sat;
                    maxDeg = node.degree;
                    bestNode = node;
                }
            }

            if (bestNode) {
                bestNode.highlight = true;
                statusText.innerText = `Selected ${bestNode.id} (Sat: ${maxSat})`;
                draw();
                await sleep(DELAY_MS);

                bestNode.color = getFirstAvailableColor(bestNode);
                addLog(`Selected ${bestNode.id} (Sat ${maxSat}): Color ${bestNode.color}`);
                bestNode.highlight = false;
                draw();
                uncolored--;
            } else break;
        }
        finishRun("DSatur");
    }

    // 4. SIMULATED ANNEALING
    async function runSimulatedAnnealing() {
        if (!prepareRun("Simulated Annealing")) return;
        DELAY_MS = 60; 
        infoOverlay.style.opacity = '1';

        addLog("Initializing random coloring...", "info");
        const K = Math.max(3, Math.floor(NODE_COUNT / 2));
        nodes.forEach(n => n.color = Math.floor(Math.random() * K));
        draw();
        await sleep(500);

        let temp = 10.0;
        const coolingRate = 0.95;
        let currentCost = countConflicts();
        let bestCost = currentCost;
        let iteration = 0;

        addLog(`Initial Cost (Conflicts): ${currentCost}`);

        while (temp > 0.1 && currentCost > 0) {
            iteration++;
            const node = nodes[Math.floor(Math.random() * nodes.length)];
            const oldColor = node.color;
            const newColor = Math.floor(Math.random() * K);

            if (oldColor === newColor) continue;

            node.color = newColor;
            let newCost = countConflicts();
            let delta = newCost - currentCost;

            let accepted = false;
            if (delta < 0) accepted = true;
            else if (Math.random() < Math.exp(-delta / temp)) accepted = true;

            if (accepted) {
                currentCost = newCost;
                if (currentCost < bestCost) bestCost = currentCost;
                
                if (iteration % 5 === 0) {
                    node.highlight = true;
                    draw();
                    infoOverlay.innerText = `Temp: ${temp.toFixed(2)} | Cost: ${currentCost}`;
                    await sleep(DELAY_MS);
                    node.highlight = false;
                }
            } else {
                node.color = oldColor; 
            }

            temp *= coolingRate;
        }

        infoOverlay.innerText = `Final Cost: ${currentCost}`;
        if (currentCost === 0) addLog("Converged to valid solution!", "success");
        else addLog("Stopped (Local Minima).", "warn");
        
        cleanupColors();
        draw();
        finishRun("Simulated Annealing");
    }

    function countConflicts() {
        let conflicts = 0;
        for (let e of edges) {
            if (nodes[e[0]].color === nodes[e[1]].color) conflicts++;
        }
        return conflicts;
    }

    function cleanupColors() {
        const map = new Map();
        let next = 0;
        nodes.forEach(n => {
            if (!map.has(n.color)) map.set(n.color, next++);
            n.color = map.get(n.color);
        });
    }

    // 5. DYNAMIC PROGRAMMING
    async function runDP() {
        if (NODE_COUNT > 8) {
            alert("WARNING: Graph is too large for DP.\n\nPlease click 'Tiny Graph (N=6)' first.");
            return;
        }

        if (!prepareRun("Dynamic Programming")) return;
        DELAY_MS = 250;
        
        addLog("Searching for optimal K...", "info");

        for (let k = 1; k <= NODE_COUNT; k++) {
            addLog(`Checking K=${k}...`, "highlight");
            statusText.innerText = `DP: Checking K=${k}`;
            nodes.forEach(n => n.color = null);
            draw();
            
            if (await backtrack(0, k)) {
                addLog(`Optimal Solution: K=${k}!`, "success");
                finishRun("Dynamic Programming");
                return;
            }
            addLog(`K=${k} impossible.`, "warn");
            await sleep(300);
        }
    }

    async function backtrack(nodeIdx, k) {
        if (nodeIdx === nodes.length) return true; 

        const node = nodes[nodeIdx];
        node.highlight = true;
        draw();
        await sleep(DELAY_MS);

        for (let c = 0; c < k; c++) {
            let valid = true;
            for (let neighbor of node.neighbors) {
                if (neighbor.color === c) {
                    valid = false;
                    break;
                }
            }

            if (valid) {
                node.color = c;
                draw();
                await sleep(DELAY_MS/2);
                if (await backtrack(nodeIdx + 1, k)) return true;
                node.color = null;
                draw();
            }
        }

        node.highlight = false;
        draw();
        return false;
    }

    // --- UTILS ---

    function validateColoring() {
        for(let node of nodes) {
            if (node.color === null) return false;
            for(let neighbor of node.neighbors) {
                if (node.color === neighbor.color) return false;
            }
        }
        return true;
    }

    function finishRun(algoName) {
        isRunning = false;
        infoOverlay.style.opacity = '0';
        let used = new Set(nodes.map(n => n.color));
        let count = used.size;
        let isValid = validateColoring();
        
        statusText.innerText = `${algoName} Done. Used ${count} Colors.`;
        addLog(`${algoName} Finished.`, "success");
        addLog(`Total Colors: ${count}`, "success");

        if(isValid) {
            validationBadge.innerText = "✓ Valid";
            validationBadge.className = "badge valid";
        } else {
            validationBadge.innerText = "⚠ Invalid";
            validationBadge.className = "badge invalid";
        }
        validationBadge.style.display = "inline-block";
    }

    // Start
    init();

</script>
</body>
</html>